<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Percorso del Filo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow-x: hidden;
            background: #000;
        }
        
        #p5-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        .scroll-space {
            height: 100000px; /* Spazio per scrollare */
        }
    </style>
</head>
<body>
    <div id="p5-canvas"></div>
    <div class="scroll-space"></div>

    <script>
        // ============ PUNTI ORIGINALI ============
        const originalPoints = [
            {x: 7853, y: 16849},
            {x: 10975, y: 21322},
            {x: 8947, y: 20178},
            {x: 11477, y: 18139},
            {x: 14239, y: 15658},
            {x: 10053, y: 13004},
            {x: 11477, y: 12162},
            {x: 16828, y: 13392},
            {x: 16577, y: 10112},
            {x: 13297, y: 5602},
            {x: 16577, y: 3789},
            {x: 16828, y: 4933},
            {x: 18166, y: 4291},
            {x: 19547, y: 6341},
            {x: 22309, y: 5602},
            {x: 24165, y: 7285},
            {x: 27035, y: 8105},
            {x: 25028, y: 11911},
            {x: 19798, y: 11409},
            {x: 23294, y: 9610},
            {x: 28861, y: 6783},
            {x: 31530, y: 5184},
            {x: 30516, y: 1861},
            {x: 34055, y: 2854},
            {x: 36321, y: 6532},
            {x: 37616, y: 9861},
            {x: 36688, y: 13011},
            {x: 30516, y: 8607},
            {x: 35372, y: 11544},
            {x: 31638, y: 18139},
            {x: 30265, y: 21613},
            {x: 35121, y: 25044},
            {x: 35833, y: 29619},
            {x: 33654, y: 35308},
            {x: 14492, y: 29676},
            {x: 2784, y: 32222}
        ];

        // ============ VARIABILI GLOBALI ============
        let scrollProgress = 0;
        let targetProgress = 0;
        let canvas;
        let bgImages = [];
        let pathPoints = []; // Punti del percorso finale
        let smoothPath = []; // Percorso lisciato
        let pathLength = 0;

        // ============ FUNZIONI UTILITY ============
        function preload() {
            // Carica le 3 immagini di sfondo
            for (let i = 1; i <= 3; i++) {
                bgImages.push(loadImage(`assets/bg-0${i}.png`));
            }
        }

        // Scala i punti e applica moltiplicatore 8
        function scalePoints(points, multiplier) {
            return points.map(p => ({
                x: p.x * multiplier,
                y: p.y * multiplier
            }));
        }

        // Crea curve morbide tra i punti (Catmull-Rom spline)
        function createSmoothPath(points, segmentsPerCurve = 20) {
            const smooth = [];
            
            for (let i = 0; i < points.length - 1; i++) {
                // Punti per la curva Catmull-Rom
                let p0, p1, p2, p3;
                
                if (i === 0) {
                    // Primo segmento
                    p0 = points[0];
                    p1 = points[0];
                    p2 = points[1];
                    p3 = points[2] || points[1];
                } else if (i === points.length - 2) {
                    // Ultimo segmento
                    p0 = points[i-1];
                    p1 = points[i];
                    p2 = points[i+1];
                    p3 = points[i+1];
                } else {
                    // Segmento centrale
                    p0 = points[i-1];
                    p1 = points[i];
                    p2 = points[i+1];
                    p3 = points[i+2];
                }
                
                // Genera punti lungo la curva
                for (let j = 0; j <= segmentsPerCurve; j++) {
                    const t = j / segmentsPerCurve;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    
                    // Formula Catmull-Rom
                    const x = 0.5 * ((2 * p1.x) +
                                    (-p0.x + p2.x) * t +
                                    (2*p0.x - 5*p1.x + 4*p2.x - p3.x) * t2 +
                                    (-p0.x + 3*p1.x - 3*p2.x + p3.x) * t3);
                    
                    const y = 0.5 * ((2 * p1.y) +
                                    (-p0.y + p2.y) * t +
                                    (2*p0.y - 5*p1.y + 4*p2.y - p3.y) * t2 +
                                    (-p0.y + 3*p1.y - 3*p2.y + p3.y) * t3);
                    
                    smooth.push({x, y});
                }
            }
            
            return smooth;
        }

        // Calcola lunghezza del percorso
        function calculatePathLength(points) {
            let length = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const dx = points[i+1].x - points[i].x;
                const dy = points[i+1].y - points[i].y;
                length += Math.sqrt(dx*dx + dy*dy);
            }
            return length;
        }

        // Trova punto su percorso in base a t (0-1)
        function getPointOnPath(t, points, totalLength) {
            t = Math.max(0, Math.min(1, t));
            
            if (t === 0) return points[0];
            if (t === 1) return points[points.length - 1];
            
            const targetLength = t * totalLength;
            
            let accumulated = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i+1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const segmentLength = Math.sqrt(dx*dx + dy*dy);
                
                if (accumulated + segmentLength >= targetLength) {
                    const segmentT = (targetLength - accumulated) / segmentLength;
                    return {
                        x: p1.x + dx * segmentT,
                        y: p1.y + dy * segmentT
                    };
                }
                accumulated += segmentLength;
            }
            
            return points[points.length - 1];
        }

        // ============ SETUP ============
        function setup() {
            canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('p5-canvas');
            
            // 1. Scala i punti (moltiplica per 8)
            pathPoints = scalePoints(originalPoints, 8);
            
            // 2. Crea percorso morbido
            smoothPath = createSmoothPath(pathPoints, 30);
            
            // 3. Calcola lunghezza
            pathLength = calculatePathLength(smoothPath);
            
            // 4. Imposta altezza scroll
            document.querySelector('.scroll-space').style.height = (pathLength/50) + 'px';
            
            // 5. Setup scroll listener
            window.addEventListener('scroll', handleScroll);
        }

        function handleScroll() {
            const scrollHeight = document.querySelector('.scroll-space').offsetHeight - window.innerHeight;
            const scrollY = window.scrollY;
            targetProgress = Math.max(0, Math.min(1, scrollY / scrollHeight));
        }

        // ============ DRAW ============
        function draw() {
            // Smooth scrolling
            scrollProgress += (targetProgress - scrollProgress) * 0.08;
            
            // Calcola punto corrente
            const currentPoint = getPointOnPath(scrollProgress, smoothPath, pathLength);
            
            // 1. Sfondo nero
            background(0);
            
            // 2. Immagini di sfondo
            drawBackground();
            
            // 3. Disegna con zoom 200%
            push();
            
            // Zoom 200%: centra e scala
            const zoom = 0.025; // Zoom 200%
            translate(width/2, height/2);
            scale(zoom);
            translate(-currentPoint.x, -currentPoint.y);
            
            // 4. Disegna percorso curvo
            drawSmoothPath();
            
            // 5. Disegna punto bianco
            drawWhiteDot(currentPoint);
            
            pop();
        }

        function drawBackground() {
            if (bgImages.length === 0) return;
            
            // Determina quale sfondo mostrare in base allo scroll
            let bgIndex;
            let opacity;
            
            if (scrollProgress < 0.33) {
                bgIndex = 0;
                opacity = map(scrollProgress, 0, 0.33, 255, 150);
            } else if (scrollProgress < 0.66) {
                bgIndex = 1;
                opacity = map(scrollProgress, 0.33, 0.66, 150, 255);
            } else {
                bgIndex = 2;
                opacity = map(scrollProgress, 0.66, 1, 255, 150);
            }
            
            const bg = bgImages[bgIndex];
            if (!bg) return;
            
            // Scala l'immagine per coprire il canvas
            const scale = Math.max(width / bg.width, height / bg.height) * 1.5;
            const imgWidth = bg.width * scale;
            const imgHeight = bg.height * scale;
            
            // Disegna con opacità
            tint(255, opacity);
            image(bg, (width - imgWidth)/2, (height - imgHeight)/2, imgWidth, imgHeight);
            
            // Overlay scuro per far risaltare il filo
            fill(0, 0, 0, 70);
            noStroke();
            rect(0, 0, width, height);
        }

        function drawSmoothPath() {
            // Disegna il percorso con curve morbide
            noFill();
            stroke(255, 80, 80); // Rosso per il filo
            strokeWeight(200); // Spessore del filo (appare più sottile per via dello zoom)
            
            // Disegna curva continua
            beginShape();
            for (const point of smoothPath) {
                vertex(point.x, point.y);
            }
            endShape();
            
            // Aggiungi un po' di glow al filo
            for (let i = 3; i > 0; i--) {
                stroke(255, 100, 100, 30);
                strokeWeight(200 + i * 50);
                noFill();
                
                beginShape();
                for (const point of smoothPath) {
                    vertex(point.x, point.y);
                }
                endShape();
            }
        }

        function drawWhiteDot(currentPoint) {
            // Punto bianco al centro
            fill(255);
            noStroke();
            ellipse(currentPoint.x, currentPoint.y, 80, 80);
            
            // Leggero glow
            for (let i = 2; i > 0; i--) {
                fill(255, 255, 255, 30);
                ellipse(currentPoint.x, currentPoint.y, 80 + i * 40, 80 + i * 40);
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>